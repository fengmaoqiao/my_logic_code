//**********************************************************
//
// Copyright(c) 2017 . Outwitcom Technology Co., LTD.
// All rights reserved.
//
// ProjectName :
// target      :
// FileName    : 
// Author      :fengmaoqiao 
// E_mail      :fengmaoqiao@outwitcom.com 
// Date        :
// Version     :
//
// Modification history
//--------------------------------------------------------
// $Log:$
// from the 32bit fifo into 64bit dinidma interface
//
//**********************************************************
module dma_if_32to64(
    //clock and reset
    input               clk                                 ,
    input               rst_n                               ,
    //user port
    input   [31:0]      s1_axis_fromhost_tdata              ,
    input               s1_axis_fromhost_tvalid             ,
    input   [3:0]       s1_axis_fromhost_tkeep              ,
    input               s1_axis_fromhost_tlast              ,
    output              s1_axis_fromhost_tready             ,

    output  reg [63:0]  m1_axis_fromhost_tdata              ,
    output  reg         m1_axis_fromhost_tvalid             ,
    output              m1_axis_fromhost_tlast              ,
    output  reg [7:0]   m1_axis_fromhost_tkeep              ,
    input               m1_axis_fromhost_tready             
        
      );

//**********************************************************
//Signal Declation
//**********************************************************
reg     [7:0]       counter_data; 
reg    [31:0]      s1_axis_fromhost_temp;
//**********************************************************
//Main Code
//**********************************************************
//compute the number of dword trans
always @(posedge clk or negedge rst_n)begin
     if(!rst_n)begin
        counter_data    <= 8'b0;    
     end
     else begin
       
            if(s1_axis_fromhost_tready && s1_axis_fromhost_tvalid && (!s1_axis_fromhost_tlast) )
               counter_data <= counter_data + 8'd1;                            
            else if(s1_axis_fromhost_tready && s1_axis_fromhost_tvalid && s1_axis_fromhost_tlast)
                counter_data <= 8'd0;
            else
                ;
    end
end
//convert the data from 32bit to 64bit
always @(*)begin

    if( counter_data[0] == 1'b1 && s1_axis_fromhost_tready)
        m1_axis_fromhost_tdata = {s1_axis_fromhost_temp,s1_axis_fromhost_tdata};

    else if(counter_data[0] == 1'b0 && s1_axis_fromhost_tlast == 1'b1 && s1_axis_fromhost_tready && s1_axis_fromhost_tvalid)
        m1_axis_fromhost_tdata = {32'b0,s1_axis_fromhost_temp};

    else
        ;
end

always @(*)begin
    
    if(counter_data[0] == 1'b0 &&  s1_axis_fromhost_tlast == 1'b0 && s1_axis_fromhost_tready && s1_axis_fromhost_tvalid)
        s1_axis_fromhost_temp = s1_axis_fromhost_tdata;
    else
        s1_axis_fromhost_temp = s1_axis_fromhost_temp;

end


//convert the tvalid signal to dma_if
always @(*)begin

    if( counter_data[0] == 1'b1 && s1_axis_fromhost_tready)
        m1_axis_fromhost_tvalid = s1_axis_fromhost_tvalid;

    else if(counter_data[0] == 1'b0 && s1_axis_fromhost_tlast == 1'b0 && s1_axis_fromhost_tready)
        m1_axis_fromhost_tvalid = 1'b0;

    else if(counter_data[0] == 1'b0 && s1_axis_fromhost_tlast == 1'b1 && s1_axis_fromhost_tready)
        m1_axis_fromhost_tvalid = s1_axis_fromhost_tvalid;

    else
        ;
end


//convert the tkeep signal to dma_if
always @(*)begin
    
    //add byte trans
    if( counter_data[0] == 1'b1 && s1_axis_fromhost_tready )
        m1_axis_fromhost_tkeep = 8'hff;

    else if(counter_data[0] == 1'b0 && s1_axis_fromhost_tlast == 1'b0 && s1_axis_fromhost_tready)
        m1_axis_fromhost_tkeep = 8'h00;

    else if(counter_data[0] == 1'b0 && s1_axis_fromhost_tlast == 1'b1 && s1_axis_fromhost_tready)
        m1_axis_fromhost_tkeep = 8'h0f;

    else
        m1_axis_fromhost_tkeep = 8'h00;
end


assign s1_axis_fromhost_tready      = m1_axis_fromhost_tready;
assign m1_axis_fromhost_tlast       = s1_axis_fromhost_tlast;


endmodule





